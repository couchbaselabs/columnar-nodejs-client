/*
 *  Copyright 2016-2024. Couchbase, Inc.
 *  All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

#pragma once
#include "addondata.hpp"
#include "instance.hpp"
#include "jstocbpp.hpp"
#include <core/utils/movable_function.hxx>
#include <napi.h>

namespace couchnode
{

typedef couchbase::core::utils::movable_function<void(Napi::Env, Napi::Function)> FwdFunc;

void
jscbForward(Napi::Env env, Napi::Function callback, std::nullptr_t*, FwdFunc* fn);
typedef Napi::TypedThreadSafeFunction<std::nullptr_t, FwdFunc, &jscbForward> CallCookieTTSF;

class CallCookie
{
public:
  CallCookie(Napi::Env env, Napi::Function jsCallback, const std::string& resourceName)
  {
    _ttsf = CallCookieTTSF::New(env, jsCallback, resourceName, 0, 1, nullptr);
    _ttsf.Ref(env);
  }

  CallCookie(CallCookie& o) = delete;

  CallCookie(CallCookie&& o)
    : _ttsf(std::move(o._ttsf))
  {
  }

  void invoke(FwdFunc&& callback)
  {
    _ttsf.BlockingCall(new FwdFunc(std::move(callback)));
    _ttsf.Release();
  }

private:
  CallCookieTTSF _ttsf;
};

class Connection : public Napi::ObjectWrap<Connection>
{
public:
  static Napi::FunctionReference& constructor(Napi::Env env)
  {
    return AddonData::fromEnv(env)->_connectionCtor;
  }

  static void Init(Napi::Env env, Napi::Object exports);

  Connection(const Napi::CallbackInfo& info);
  ~Connection();

  couchbase::core::cluster cluster() const
  {
    return _instance->_cluster;
  }

  Napi::Value jsConnect(const Napi::CallbackInfo& info);
  Napi::Value jsShutdown(const Napi::CallbackInfo& info);
  Napi::Value jsOpenBucket(const Napi::CallbackInfo& info);
  Napi::Value jsQuery(const Napi::CallbackInfo& info);

  // #region Autogenerated Method Declarations

  // #endregion Autogenerated Method Declarations

private:
  template<typename Request, typename Handler>
  void executeOp(const std::string& opName,
                 const Request& req,
                 Napi::Function jsCallback,
                 Handler&& handler)
  {
    using response_type = typename Request::response_type;

    auto cookie = CallCookie(jsCallback.Env(), jsCallback, opName);
    this->_instance->_cluster.execute(
      req, [cookie = std::move(cookie), handler = std::move(handler)](response_type resp) mutable {
        cookie.invoke([handler = std::move(handler),
                       resp = std::move(resp)](Napi::Env env, Napi::Function callback) mutable {
          handler(env, callback, std::move(resp));
        });
      });
  }

  template<typename Request>
  void executeOp(const std::string& opName, const Request& req, Napi::Function jsCallback)
  {
    using response_type = typename Request::response_type;
    executeOp(opName,
              req,
              jsCallback,
              [](Napi::Env env, Napi::Function callback, response_type resp) mutable {
                Napi::Value jsErr, jsRes;
                try {
                  jsErr = cbpp_to_js(env, resp.ctx);
                  jsRes = cbpp_to_js(env, resp);
                } catch (const Napi::Error& e) {
                  jsErr = e.Value();
                  jsRes = env.Null();
                }

                callback.Call({ jsErr, jsRes });
              });
  }

  Instance* _instance;
};

} // namespace couchnode
