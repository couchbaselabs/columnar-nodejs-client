#include "connection.hpp"
#include "instance.hpp"
#include "jstocbpp.hpp"
#include "query_result.hpp"
#include <core/agent_group.hxx>
#include <core/operations/management/freeform.hxx>
#include <core/utils/connection_string.hxx>
#include <future>
#include <type_traits>

namespace couchnode
{

void
jscbForward(Napi::Env env, Napi::Function callback, std::nullptr_t*, FwdFunc* fn)
{
  if (env == nullptr || callback == nullptr) {
    delete fn;
    return;
  }

  try {
    (*fn)(env, callback);
  } catch (const Napi::Error& e) {
  }
  delete fn;
}

void
Connection::Init(Napi::Env env, Napi::Object exports)
{
  Napi::Function func = DefineClass(env,
                                    "Connection",
                                    {
                                      InstanceMethod<&Connection::jsConnect>("connect"),
                                      InstanceMethod<&Connection::jsShutdown>("shutdown"),
                                      InstanceMethod<&Connection::jsOpenBucket>("openBucket"),
                                      InstanceMethod<&Connection::jsQuery>("query"),

                                      // #region Autogenerated Method Registration

                                      // #endregion Autogenerated Method Registration
                                    });

  constructor(env) = Napi::Persistent(func);
  exports.Set("Connection", func);
}

Connection::Connection(const Napi::CallbackInfo& info)
  : Napi::ObjectWrap<Connection>(info)
{
  _instance = new Instance();
}

Connection::~Connection()
{
  _instance->asyncDestroy();
  _instance = nullptr;
}

Napi::Value
Connection::jsConnect(const Napi::CallbackInfo& info)
{
  auto connstr = info[0].ToString().Utf8Value();
  auto credentialsJsObj = info[1].As<Napi::Object>();
  auto securityJsObj = info[2].As<Napi::Object>();

  auto connstrInfo = couchbase::core::utils::parse_connection_string(connstr);
  auto creds = jsToCbpp<couchbase::core::cluster_credentials>(credentialsJsObj);

  connstrInfo.options.security_options =
    jsToCbpp<couchbase::core::columnar::security_options>(securityJsObj);

  if (!info[3].IsNull()) {
    auto jsDnsConfigObj = info[3].As<Napi::Object>();
    auto jsNameserver = jsDnsConfigObj.Get("nameserver");
    if (jsNameserver.IsNull() || jsNameserver.IsUndefined() || jsNameserver.IsEmpty()) {
      jsDnsConfigObj.Set(
        "nameserver",
        cbpp_to_js<std::string>(info.Env(), connstrInfo.options.dns_config.nameserver()));
    }
    auto jsPort = jsDnsConfigObj.Get("port");
    if (jsPort.IsNull() || jsPort.IsUndefined()) {
      jsDnsConfigObj.Set(
        "port", cbpp_to_js<std::uint16_t>(info.Env(), connstrInfo.options.dns_config.port()));
    }
    auto jsTimeout = jsDnsConfigObj.Get("dnsSrvTimeout");
    if (jsTimeout.IsNull() || jsTimeout.IsUndefined()) {
      jsDnsConfigObj.Set("dnsSrvTimeout",
                         cbpp_to_js<std::chrono::milliseconds>(
                           info.Env(), connstrInfo.options.dns_config.timeout()));
    }
    auto cppDnsConfig = jsToCbpp<couchbase::core::io::dns::dns_config>(jsDnsConfigObj);
    connstrInfo.options.dns_config = cppDnsConfig;
  }

  auto barrier = std::make_shared<std::promise<std::error_code>>();
  auto f = barrier->get_future();
  this->_instance->_cluster.open_in_background(couchbase::core::origin(creds, connstrInfo),
                                               [barrier](std::error_code ec) mutable {
                                                 if (ec) {
                                                   barrier->set_value(ec);
                                                 } else {
                                                   barrier->set_value({});
                                                 }
                                               });

  auto env = info.Env();
  auto open_ec = f.get();
  if (open_ec) {
    return cbpp_to_js(env, open_ec);
  }
  return env.Null();
}

Napi::Value
Connection::jsShutdown(const Napi::CallbackInfo& info)
{
  auto callbackJsFn = info[0].As<Napi::Function>();

  auto cookie = CallCookie(info.Env(), callbackJsFn, "cbShutdownCallback");
  this->_instance->_cluster.close([cookie = std::move(cookie)]() mutable {
    cookie.invoke([](Napi::Env env, Napi::Function callback) {
      callback.Call({ env.Null() });
    });
  });

  return info.Env().Null();
}

Napi::Value
Connection::jsOpenBucket(const Napi::CallbackInfo& info)
{
  auto bucketName = info[0].ToString().Utf8Value();
  auto callbackJsFn = info[1].As<Napi::Function>();

  auto cookie = CallCookie(info.Env(), callbackJsFn, "cbOpenBucketCallback");
  this->_instance->_cluster.open_bucket(
    bucketName, [cookie = std::move(cookie)](std::error_code ec) mutable {
      cookie.invoke([ec](Napi::Env env, Napi::Function callback) {
        callback.Call({ cbpp_to_js(env, ec) });
      });
    });

  return info.Env().Null();
}

Napi::Value
Connection::jsQuery(const Napi::CallbackInfo& info)
{
  auto optionsObj = info[0].As<Napi::Object>();
  auto callbackJsFn = info[1].As<Napi::Function>();

  auto env = info.Env();
  auto resObj = Napi::Object::New(env);

  auto options = js_to_cbpp<couchbase::core::columnar::query_options>(optionsObj);

  auto cookie = CallCookie(env, callbackJsFn, "cbQueryCallback");

  auto handler = [](Napi::Env env,
                    Napi::Function callback,
                    QueryResult* queryResult,
                    couchbase::core::columnar::query_result resp,
                    couchbase::core::columnar::error err) mutable {
    try {
      if (err.ec) {
        auto jsErr = cbpp_to_js(env, err);
        callback.Call({ jsErr });
      } else {
        queryResult->setQueryResult(resp);
        callback.Call({ env.Null() });
      }
    } catch (const Napi::Error& e) {
      callback.Call({ e.Value() });
    }
  };

  auto queryResult = QueryResult::constructor(env).New({});
  auto queryResultPtr = QueryResult::Unwrap(queryResult);

  auto resp = this->_instance->_agent.execute_query(
    options,
    [queryResultPtr, cookie = std::move(cookie), handler = std::move(handler)](
      couchbase::core::columnar::query_result resp, couchbase::core::columnar::error err) mutable {
      cookie.invoke([queryResultPtr,
                     handler = std::move(handler),
                     resp = std::move(resp),
                     err = std::move(err)](Napi::Env env, Napi::Function callback) mutable {
        handler(env, callback, queryResultPtr, std::move(resp), std::move(err));
      });
    });

  if (!resp.has_value()) {
    resObj.Set("cppQueryErr", cbpp_to_js(env, resp.error()));
    resObj.Set("cppQueryResult", env.Null());
    return resObj;
  }
  queryResultPtr->setPendingOp(resp.value());
  resObj.Set("cppQueryErr", env.Null());
  resObj.Set("cppQueryResult", queryResult);
  return resObj;
}

} // namespace couchnode
