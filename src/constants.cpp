#include "constants.hpp"
#include "jstocbpp.hpp"
#include <core/cluster.hxx>
#include <core/columnar/error_codes.hxx>
#include <core/impl/subdoc/path_flags.hxx>
#include <core/transactions.hxx>
#include <core/transactions/internal/exceptions_internal.hxx>
#include <couchbase/error_context.hxx>
#include <set>
#include <vector>

namespace couchnode
{

template<typename T>
static inline Napi::Object
cbppEnumToJs(Napi::Env env, const std::vector<std::pair<std::string, T>>& values)
{
  auto jsVals = Napi::Object::New(env);
  auto dedupValues = std::set<T>();
  for (const auto& value : values) {
    auto dedupRes = dedupValues.emplace(value.second);
    if (!dedupRes.second) {
      throw Napi::Error::New(env, "duplicate constants during initialization");
    }

    jsVals.Set(value.first, Napi::Number::New(env, static_cast<int64_t>(value.second)));
  }
  return jsVals;
}

void
Constants::Init(Napi::Env env, Napi::Object exports)
{
  InitAutogen(env, exports);
}

void
Constants::InitAutogen(Napi::Env env, Napi::Object exports)
{
  // #region Autogenerated Constants

  exports.Set(
    "retry_reason",
    cbppEnumToJs<couchbase::retry_reason>(
      env,
      {
        { "do_not_retry", couchbase::retry_reason::do_not_retry },
        { "unknown", couchbase::retry_reason::unknown },
        { "socket_not_available", couchbase::retry_reason::socket_not_available },
        { "service_not_available", couchbase::retry_reason::service_not_available },
        { "node_not_available", couchbase::retry_reason::node_not_available },
        { "key_value_not_my_vbucket", couchbase::retry_reason::key_value_not_my_vbucket },
        { "key_value_collection_outdated", couchbase::retry_reason::key_value_collection_outdated },
        { "key_value_error_map_retry_indicated",
          couchbase::retry_reason::key_value_error_map_retry_indicated },
        { "key_value_locked", couchbase::retry_reason::key_value_locked },
        { "key_value_temporary_failure", couchbase::retry_reason::key_value_temporary_failure },
        { "key_value_sync_write_in_progress",
          couchbase::retry_reason::key_value_sync_write_in_progress },
        { "key_value_sync_write_re_commit_in_progress",
          couchbase::retry_reason::key_value_sync_write_re_commit_in_progress },
        { "service_response_code_indicated",
          couchbase::retry_reason::service_response_code_indicated },
        { "socket_closed_while_in_flight", couchbase::retry_reason::socket_closed_while_in_flight },
        { "circuit_breaker_open", couchbase::retry_reason::circuit_breaker_open },
        { "query_prepared_statement_failure",
          couchbase::retry_reason::query_prepared_statement_failure },
        { "query_index_not_found", couchbase::retry_reason::query_index_not_found },
        { "analytics_temporary_failure", couchbase::retry_reason::analytics_temporary_failure },
        { "search_too_many_requests", couchbase::retry_reason::search_too_many_requests },
        { "views_temporary_failure", couchbase::retry_reason::views_temporary_failure },
        { "views_no_active_partition", couchbase::retry_reason::views_no_active_partition },
      }));

  exports.Set(
    "columnar_query_scan_consistency",
    cbppEnumToJs<couchbase::core::columnar::query_scan_consistency>(
      env,
      {
        { "not_bounded", couchbase::core::columnar::query_scan_consistency::not_bounded },
        { "request_plus", couchbase::core::columnar::query_scan_consistency::request_plus },
      }));

  exports.Set("columnar_errc",
              cbppEnumToJs<couchbase::core::columnar::errc>(
                env,
                {
                  { "generic", couchbase::core::columnar::errc::generic },
                  { "invalid_credential", couchbase::core::columnar::errc::invalid_credential },
                  { "timeout", couchbase::core::columnar::errc::timeout },
                  { "query_error", couchbase::core::columnar::errc::query_error },
                }));

  // #endregion Autogenerated Constants
}

} // namespace couchnode
